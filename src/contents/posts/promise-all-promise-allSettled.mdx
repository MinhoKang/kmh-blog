---
title: "Promise.all vs Promise.allSettled"
description: "JavaScript의 Promise.all과 Promise.allSettled의 차이점"
startDate: "2025-09-25"
tags: ["Promise"]
category: "posts"
featured: true
published: true
---

## Promise.all과 Promise.allSettled란?

Promise.all과 Promise.allSettled는 모두 여러 개의 비동기 작업을 동시에 처리하기 위한 JavaScript의 내장 메서드이다. 두 메서드 모두 프로미스 배열을 받아서 병렬로 실행시키지만, 실패 처리 방식에서 큰 차이를 보인다.

## Promise.all의 특징

Promise.all은 '모 아니면 도' 방식으로 동작한다. 즉, 모든 프로미스가 성공해야만 전체가 성공으로 처리되고, 하나라도 실패하면 즉시 전체가 실패로 처리되는 fail-fast 방식이다.

### Promise.all 사용 예시

```javascript
const promise1 = new Promise((resolve) => {
  setTimeout(() => resolve(1), 3000);
});

const promise2 = new Promise((resolve) => {
  setTimeout(() => resolve(2), 2000);
});

const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then((result) => console.log(result)) // [1, 2, 3]
  .catch((error) => console.error(error));
```

이 경우 모든 프로미스가 성공하므로 3초 후에 [1, 2, 3] 배열이 반환된다.

### Promise.all의 실패 케이스

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(new Error("실패!"));
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then((result) => console.log(result))
  .catch((error) => console.error(error)); // Error: 실패!
```

이 경우 promise2가 실패하면 즉시 catch 블록으로 이동하며, 다른 프로미스들의 결과는 무시된다.

## Promise.allSettled의 특징

Promise.allSettled는 '안정된(settled)' 메서드로, 모든 프로미스가 완료될 때까지 기다린다. 성공이든 실패든 상관없이 모든 프로미스의 결과를 받을 수 있다.

### Promise.allSettled 사용 예시

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(new Error("실패!"));
const promise3 = Promise.resolve(3);

Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  results.forEach((result) => {
    console.log(result);
  });
});
```

결과는 다음과 같이 나온다:

```javascript
// { status: 'fulfilled', value: 1 }
// { status: 'rejected', reason: Error: 실패! }
// { status: 'fulfilled', value: 3 }
```

성공한 프로미스는 `status: 'fulfilled'`와 `value`를 가지고, 실패한 프로미스는 `status: 'rejected'`와 `reason`을 가진다.

## 주요 차이점 비교표

| 구분        | Promise.all                    | Promise.allSettled                       |
| ----------- | ------------------------------ | ---------------------------------------- |
| 실패 처리   | 하나라도 실패하면 전체 실패    | 실패해도 모든 결과 반환                  |
| 반환 형태   | 성공값 배열 또는 에러          | 상태 객체 배열                           |
| 사용 케이스 | 모든 작업이 성공해야 하는 경우 | 각 작업의 결과를 모두 확인해야 하는 경우 |
| 에러 핸들링 | catch로 처리                   | status 값으로 분기 처리                  |

## 언제 어떤 메서드를 사용할까?

### Promise.all을 사용하는 경우

- 여러 API 호출이 모두 성공해야만 다음 단계로 진행할 수 있는 경우
- 데이터베이스 트랜잭션처럼 하나라도 실패하면 전체를 롤백해야 하는 경우
- 모든 의존성이 성공적으로 로드되어야 앱이 시작되는 경우

### Promise.allSettled를 사용하는 경우

- 여러 서비스에서 데이터를 가져오는데, 일부가 실패해도 나머지 데이터는 사용해야 하는 경우
- 로그 전송, 통계 수집 등 실패해도 메인 기능에 영향을 주지 않는 작업들
- 각 프로미스의 성공/실패 여부를 개별적으로 처리해야 하는 경우

## 실제 활용 예시

```javascript
// 사용자 프로필 페이지 로딩
const userProfile = fetchUserProfile(userId);
const userPosts = fetchUserPosts(userId);
const userFriends = fetchUserFriends(userId);

// 모든 데이터가 필요한 경우
Promise.all([userProfile, userPosts, userFriends])
  .then(([profile, posts, friends]) => {
    renderProfilePage(profile, posts, friends);
  })
  .catch((error) => {
    showErrorPage(error);
  });

// 일부 데이터가 없어도 페이지를 보여줄 수 있는 경우
Promise.allSettled([userProfile, userPosts, userFriends]).then((results) => {
  const profile = results[0].status === "fulfilled" ? results[0].value : null;
  const posts = results[1].status === "fulfilled" ? results[1].value : [];
  const friends = results[2].status === "fulfilled" ? results[2].value : [];

  renderProfilePage(profile, posts, friends);
});
```

## 정리

Promise.all은 엄격한 성공 조건이 필요할 때, Promise.allSettled는 유연한 결과 처리가 필요할 때 사용하는 것이 좋다. 최근에는 안정성 때문에 Promise.allSettled를 더 많이 사용하는 추세이며, status 값을 통해 각 프로미스의 결과를 세밀하게 제어할 수 있다는 장점이 있다.
