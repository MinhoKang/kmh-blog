---
title: "[시리즈 5편] React에서 녹음 기능 구현하기 - 실전 통합과 성능 최적화, 프로덕션 레벨 녹음 시스템"
description: "메모리 누수 방지부터 성능 최적화까지, 실제 서비스 배포를 위한 완성형 가이드"
startDate: "2025-09-25"
tags: ["React", "오디오 녹음", "성능 최적화", "프로덕션", "메모리 관리", "시리즈"]
category: "posts"
featured: true
published: false
---

## 모든 퍼즐 조각을 맞추기: RecordModal의 완성형

지금까지 Navigator의 브라우저 탐험, 오디오 API의 레고 블록 조립, 데이터 처리의 택배 상자와 프리즘, 그리고 React 훅의 전문가 팀까지 살펴봤다. 이제 이 모든 것을 하나로 합쳐 **실제 동작하는 완성품**을 만들어보자.

실제 `RecordModal`에서 이런 모든 요소들이 어떻게 조화롭게 동작하는지 보면, 마치 **오케스트라의 완벽한 협연**과 같다:

```javascript
export const RecordModal = ({ modal }) => {
  // 1단계: 전문가 팀 소집 (각 훅들이 자신의 역할 담당)
  const { audioContext, isRunning, resume: resumeAudioContext } = useAudioContext();
  const { stream, isEnabled, permission, error: micError, enable, disable } = useMicrophone();
  const { level } = useAudioMeter({ audioContext, stream });
  const {
    isRecording,
    isPaused,
    start,
    pause,
    resume,
    stop,
    reset,
    error: recError,
  } = useMediaRecorder(stream);
  const { formattedTime, reset: resetTimer } = useRecordingTimer(isRecording, isPaused);
  const { isPlaying, audioRef, playPause, resetPlayer, handleAudioEnded } = useAudioPlayer();

  // 2단계: 상태 통합 관리
  const [downloadUrl, setDownloadUrl] = useState(null);
  const canRecord = useMemo(() => Boolean(stream && audioContext), [stream, audioContext]);

  // 3단계: 마스터 컨트롤러 (모든 것을 조율하는 지휘자)
  async function handleRecordClick() {
    // 순차적 활성화 (중요한 순서!)
    if (!isRunning) await resumeAudioContext(); // 오디오 환경 먼저
    if (!isEnabled) await enable(); // 그 다음 마이크

    if (!isRecording) {
      // 녹음 시작: 모든 상태 초기화
      setDownloadUrl(null); // 이전 파일 정리
      resetPlayer(); // 플레이어 초기화
      reset(); // 레코더 초기화
      resetTimer(); // 타이머 초기화
      start(); // 마침내 녹음 시작!
    } else {
      // 녹음 정지: Blob 생성 후 다운로드 URL 만들기
      const blob = await stop();
      if (blob) setDownloadUrl(URL.createObjectURL(blob));
    }
  }

  // 4단계: 일시정지/재개 제어
  async function handlePauseResumeClick() {
    if (!isRunning) await resumeAudioContext();
    if (!isEnabled) await enable();

    if (isPaused) {
      resume(); // 일시정지에서 재개
    } else {
      pause(); // 녹음 중에서 일시정지
    }
  }

  return (
    <Modal {...modal} isOpen width="360px">
      <div className="flex w-full flex-col items-center justify-center gap-y-5">
        {/* 실시간 오디오 레벨 표시 */}
        <AudioLevelMeter level={level} className="h-8" />

        {/* 녹음 시간과 상태 표시 */}
        <div className="recording-status">
          <div
            className={`status-indicator ${
              isRecording ? (isPaused ? "paused" : "recording") : "idle"
            }`}
          >
            {isRecording ? (isPaused ? "⏸️" : "🔴") : "⚪"}
          </div>
          <span>{formattedTime}</span>
        </div>

        {/* 녹음 컨트롤 버튼들 */}
        <div className="control-buttons">
          <button onClick={handleRecordClick} disabled={!canRecord}>
            {isRecording ? "⏹️ 정지" : "🎤 녹음"}
          </button>

          {isRecording && (
            <button onClick={handlePauseResumeClick}>{isPaused ? "▶️ 재개" : "⏸️ 일시정지"}</button>
          )}
        </div>

        {/* 에러 표시 */}
        {(micError || recError) && <div className="error-message">{micError || recError}</div>}

        {/* 녹음 완료 후 재생 및 다운로드 */}
        {downloadUrl && (
          <div className="playback-section">
            <audio ref={audioRef} src={downloadUrl} onEnded={handleAudioEnded} />
            <button onClick={playPause}>
              {isPlaying ? "⏸️" : "▶️"} {isPlaying ? "정지" : "재생"}
            </button>
            <a href={downloadUrl} download="녹음파일.webm">
              💾 다운로드
            </a>
          </div>
        )}
      </div>
    </Modal>
  );
};
```

> **지휘자의 중요성**
>
> `handleRecordClick` 함수가 바로 오케스트라의 지휘자 역할을 한다. 각 전문가(훅)들이 아무리 뛰어나도, 이들을 적절한 순서와 타이밍으로 조율하는 지휘자가 없으면 혼란이 발생한다. 특히 오디오 시스템에서는 AudioContext → 마이크 → 녹음의 순서가 매우 중요하다.

## 성능 최적화: CPU와 메모리의 현명한 사용

### requestAnimationFrame vs setInterval: 프레임의 지혜

실시간 오디오 분석에서 가장 중요한 최적화 포인트는 **언제, 얼마나 자주 분석할 것인가**이다. 이를 자동차 운전에 비유하면, 계기판을 1초에 100번 확인하는 것과 필요할 때만 확인하는 것의 차이와 같다.

```javascript
// ❌ 나쁜 예: CPU를 혹사시키는 방법
setInterval(() => {
  analyzeAudio(); // 브라우저가 바쁘든 말든 무조건 실행
}, 16); // 1초에 60번 강제 실행

// ✅ 좋은 예: 브라우저와 협력하는 방법
function smartAnalysis() {
  analyzeAudio();
  // 브라우저가 여유로울 때만 다음 분석 예약
  requestAnimationFrame(smartAnalysis);
}
```

실제 `useAudioMeter` 훅에서 이런 최적화가 적용된 모습을 보자:

```javascript
export function useAudioMeter({ audioContext, stream }) {
  const rafRef = useRef(null);
  const [level, setLevel] = useState(0);

  useEffect(() => {
    if (!audioContext || !stream) return;

    const analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);

    const data = new Uint8Array(analyser.frequencyBinCount);

    // 스마트한 분석 루프
    const tick = () => {
      // 탭이 활성화되어 있을 때만 분석
      if (document.hidden) {
        rafRef.current = requestAnimationFrame(tick);
        return;
      }

      analyser.getByteTimeDomainData(data);

      // RMS 계산 최적화 (불필요한 계산 줄이기)
      let sum = 0;
      const sampleRate = Math.max(1, Math.floor(data.length / 32)); // 샘플링 간소화

      for (let i = 0; i < data.length; i += sampleRate) {
        const v = (data[i] - 128) / 128;
        sum += v * v;
      }

      const rms = Math.sqrt(sum / (data.length / sampleRate));
      setLevel(rms);

      rafRef.current = requestAnimationFrame(tick);
    };

    rafRef.current = requestAnimationFrame(tick);

    return cleanup;
  }, [audioContext, stream]);

  return { level };
}
```

> **탭 비활성화 감지의 중요성**
>
> 사용자가 다른 탭으로 이동했을 때도 계속 분석을 수행하면 배터리와 CPU를 낭비한다. `document.hidden`을 체크해서 백그라운드에서는 분석을 건너뛰는 것이 좋은 최적화 기법이다.

### 메모리 누수: 디지털 세상의 물 새는 수도꼭지

메모리 누수를 **물이 새는 수도꼭지**에 비유하면 이해하기 쉽다. 한 방울씩 떨어지는 물은 처음에는 별 것 아닌 것 같지만, 시간이 지나면 큰 낭비가 된다.

오디오 애플리케이션에서 흔한 메모리 누수 패턴들을 살펴보자:

#### 1. 이벤트 리스너의 무한 증식

```javascript
// ❌ 메모리 누수의 원인
function BadAudioComponent() {
  const [volume, setVolume] = useState(0);

  useEffect(() => {
    const updateVolume = () => setVolume(Math.random());

    // 이벤트 리스너만 추가하고 제거는 안 함!
    setInterval(updateVolume, 100);
    // return cleanup 함수가 없음 = 누수 발생
  }, []);

  return <div>Volume: {volume}</div>;
}

// ✅ 메모리 안전한 버전
function GoodAudioComponent() {
  const [volume, setVolume] = useState(0);
  const intervalRef = useRef(null);

  useEffect(() => {
    const updateVolume = () => setVolume(Math.random());

    intervalRef.current = setInterval(updateVolume, 100);

    // 🔧 수도꼭지 잠그기 = cleanup!
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, []);

  return <div>Volume: {volume}</div>;
}
```

#### 2. URL 객체의 방치

```javascript
// ❌ 브라우저 메모리에 파일이 계속 쌓임
function BadDownloader() {
  const handleDownload = async () => {
    const blob = await createAudioBlob();
    const url = URL.createObjectURL(blob); // 메모리에 URL 생성
    downloadFile(url);
    // URL을 해제하지 않음 = 파일이 메모리에 계속 남아있음
  };
}

// ✅ 사용 후 바로 정리하는 버전
function GoodDownloader() {
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleDownload = async () => {
    const blob = await createAudioBlob();
    const url = URL.createObjectURL(blob);
    setDownloadUrl(url);

    // 일정 시간 후 자동 정리
    setTimeout(() => {
      URL.revokeObjectURL(url); // 🗑️ 메모리에서 제거
      setDownloadUrl(null);
    }, 10000); // 10초 후 정리
  };

  // 컴포넌트 언마운트 시에도 정리
  useEffect(() => {
    return () => {
      if (downloadUrl) {
        URL.revokeObjectURL(downloadUrl);
      }
    };
  }, [downloadUrl]);

  return (
    <div>
      <button onClick={handleDownload}>파일 생성</button>
      {downloadUrl && (
        <a href={downloadUrl} download="audio.webm">
          다운로드
        </a>
      )}
    </div>
  );
}
```

#### 3. 오디오 리소스의 좀비화

```javascript
// ❌ AudioContext가 좀비처럼 살아남는 경우
function ZombieAudio() {
  const [audioContext, setAudioContext] = useState(null);

  useEffect(() => {
    const ctx = new AudioContext();
    setAudioContext(ctx);
    // cleanup 없음 = AudioContext가 영원히 살아있음
  }, []);
}

// ✅ 깔끔하게 정리하는 버전
function CleanAudio() {
  const [audioContext, setAudioContext] = useState(null);
  const ctxRef = useRef(null);

  useEffect(() => {
    const ctx = new AudioContext();
    setAudioContext(ctx);
    ctxRef.current = ctx;

    return () => {
      // 🧹 모든 오디오 리소스 정리
      if (ctxRef.current) {
        ctxRef.current.close().catch(() => {}); // 에러가 나도 무시하고 정리
        ctxRef.current = null;
      }
      setAudioContext(null);
    };
  }, []);
}
```

#### 4. MediaStream 트랙의 좀비화

```javascript
// ❌ 마이크 트랙이 계속 살아있는 경우
function ZombieMicrophone() {
  const [stream, setStream] = useState(null);

  const startMic = async () => {
    const mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    setStream(mediaStream);
    // 트랙 정리 로직 없음 = 마이크가 계속 켜져있음
  };
}

// ✅ 트랙까지 깔끔하게 정리하는 버전
function CleanMicrophone() {
  const [stream, setStream] = useState(null);
  const streamRef = useRef(null);

  const startMic = async () => {
    // 기존 스트림이 있으면 먼저 정리
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
    }

    const mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    setStream(mediaStream);
    streamRef.current = mediaStream;
  };

  const stopMic = () => {
    if (streamRef.current) {
      // 🔇 모든 트랙 정지 (마이크 LED 꺼짐)
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }
    setStream(null);
  };

  // 컴포넌트 언마운트 시 자동 정리
  useEffect(() => {
    return () => {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach((track) => track.stop());
      }
    };
  }, []);

  return (
    <div>
      <button onClick={startMic}>🎤 마이크 시작</button>
      <button onClick={stopMic}>🔇 마이크 정지</button>
    </div>
  );
}
```

> **메모리 누수 디버깅 팁**
>
> Chrome 개발자 도구의 Performance 탭에서 메모리 사용량을 모니터링할 수 있다. 시간이 지날수록 메모리 사용량이 계속 증가한다면 누수가 의심된다. 특히 오디오 관련 작업 후 메모리가 해제되지 않는다면 cleanup 함수를 확인해보자.

### 통합적인 리소스 관리

모든 훅들이 협력해서 안전하게 리소스를 관리하는 방법을 보자:

```javascript
// 🏭 리소스를 안전하게 관리하는 통합 시스템
function ResourceSafeRecordingApp() {
  // 각 훅들이 자신의 리소스를 스스로 관리
  const audioContextHook = useAudioContext();
  const microphoneHook = useMicrophone();
  const meterHook = useAudioMeter({
    audioContext: audioContextHook.audioContext,
    stream: microphoneHook.stream,
  });
  const recorderHook = useMediaRecorder(microphoneHook.stream);

  // 전체 정리 함수 (비상시 사용)
  const emergencyCleanup = useCallback(() => {
    // 1. 녹음 정지
    if (recorderHook.isRecording) {
      recorderHook.stop();
    }

    // 2. 마이크 정지
    microphoneHook.disable();

    // 3. 기타 정리는 각 훅의 cleanup에서 자동으로
    console.log("🧹 비상 정리 완료!");
  }, [recorderHook, microphoneHook]);

  // 페이지를 떠날 때 자동 정리
  useEffect(() => {
    const handleBeforeUnload = () => {
      emergencyCleanup();
    };

    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
      emergencyCleanup(); // 컴포넌트 언마운트 시에도 정리
    };
  }, [emergencyCleanup]);

  return (
    <div>
      <RecordModal
        audioContext={audioContextHook}
        microphone={microphoneHook}
        meter={meterHook}
        recorder={recorderHook}
      />
    </div>
  );
}
```

## 시리즈를 마무리하며

5편에 걸쳐 함께한 React 오디오 녹음 시스템 구축 여정이 이제 마무리된다. Navigator의 브라우저 탐험부터 시작해서, Web Audio API의 레고 블록 조립, 데이터 처리의 택배와 프리즘, React 훅의 전문가 팀 구성, 그리고 마지막으로 실전 최적화까지 다뤘다.

### 무엇을 배웠는가

- **기초 탄탄히**: 브라우저의 기본 동작 원리부터 차근차근
- **모듈화 설계**: 복잡한 시스템을 관리 가능한 크기로 나누기
- **성능 최적화**: 메모리와 CPU를 현명하게 사용하는 방법
- **리소스 관리**: 메모리 누수 없는 안전한 코드 작성법
- **통합 아키텍처**: 모든 부분이 조화롭게 동작하는 시스템 구축

### 핵심 원칙들

1. **단계별 접근**: 복잡한 것도 작은 단위로 나누면 이해할 수 있다
2. **적절한 비유**: 레고, 택배, 오케스트라 같은 친숙한 개념으로 설명하면 쉽다
3. **안전한 설계**: 항상 cleanup을 염두에 두고 코드를 작성한다
4. **사용자 중심**: 기술적 완성도보다 사용자 경험이 우선이다

### 실제로 적용해보기

이제 배운 내용을 실제 프로젝트에 적용해볼 차례이다. 단순한 녹음 기능부터 시작해서, 점진적으로 고급 기능을 추가해나가면 된다.

가장 중요한 것은 **사용자 경험**이다. 아무리 기술적으로 뛰어난 시스템이라도 사용자가 쉽고 편하게 사용할 수 없다면 의미가 없다. 항상 사용자의 입장에서 생각하고, 세심한 배려를 담아 개발하자.

복잡해 보이는 오디오 시스템도 적절한 비유와 단계별 접근으로 충분히 이해하고 구현할 수 있다. 레고 블록을 조립하듯, 택배를 포장하듯, 오케스트라를 지휘하듯 - 이런 친숙한 개념들로 접근하면 어려운 기술도 재미있게 배울 수 있을 것이다.

이제 여러분만의 멋진 오디오 애플리케이션을 만들어보자! 🎵🚀
